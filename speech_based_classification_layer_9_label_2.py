# -*- coding: utf-8 -*-
"""Speech-based_Classification_Layer-9_Label-2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sr-fTGqlQ049IdTjrYEhT693ChzoPgdz

# Library Imports
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split
from sklearn.feature_selection import VarianceThreshold
import seaborn as sns
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score

"""# Import Datasets"""

train_csv_url = "/content/drive/MyDrive/#Semester07/CS4622/ML Project/speech-based-classification-layer-9/train.csv"
valid_csv_url = "/content/drive/MyDrive/#Semester07/CS4622/ML Project/speech-based-classification-layer-9/valid.csv"
test_csv_url = "/content/drive/MyDrive/#Semester07/CS4622/ML Project/speech-based-classification-layer-9/test.csv"

train_data = pd.read_csv(train_csv_url)
valid_data = pd.read_csv(valid_csv_url)
test_data = pd.read_csv(test_csv_url)

print("Train data:")
print(train_data.head())
print("Valid data:")
print(valid_data.head())
print("Test data:")
print(test_data.head())

"""# Data Visualization"""

def visualize_label(y, title, x_title, y_title='Number of entries'):
  unique_classes, class_counts = np.unique(y, return_counts=True)
  plt.bar(unique_classes, class_counts)
  plt.xlabel(x_title)
  plt.ylabel(y_title)
  plt.title(title)
  plt.show()

visualize_label(train_data['label_2'], "Number of rows versus Age","Age")

visualize_label(valid_data['label_2'], "Number of rows versus Age","Age")

"""# Outlier Detection and Removal"""

from scipy.stats import norm

def visualize_label_norm(y, title, x_title, y_title='Number of entries'):
  unique_classes, class_counts = np.unique(y, return_counts=True)
  plt.bar(unique_classes, class_counts)
  plt.xlabel(x_title)
  plt.ylabel(y_title)
  plt.title(title)

  rng = np.arange(train_data["label_2"].min(), train_data["label_2"].max(), 0.1)
  plt.plot(rng, norm.pdf(rng,train_data["label_2"].mean(),train_data["label_2"].std()))
  plt.show()

visualize_label_norm(train_data['label_2'], "Number of rows versus Age","Age")

train_data['zscore'] = ( train_data["label_2"] - train_data["label_2"].mean() ) / train_data["label_2"].std()
outliers = train_data[(train_data.zscore<-3) | (train_data.zscore>3)]
outliers.shape

"""467 outliers to remove

# Train without Feaure Reduction
"""

print(f"train_data dataset shape {train_data.shape}")
print(f"# of missing values {train_data['label_2'].isna().sum()}")
print(f"# of labels {train_data['label_2'].value_counts().shape[0]}")
print(f"label summary\n{train_data['label_2'].value_counts()}")

train_data.dropna(subset=['label_2'], inplace=True)
print(f"train_data dataset shape {train_data.shape}")

"""Feature Enginering

*   Label_2 has missing values and they were dropped
*   Label_2 has 17 unique classes
*   Using one-hot encoding for multilabel classification


"""

label_2 = train_data['label_2'].values.reshape(-1, 1)
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(label_2)
print(ohe.categories_)

label_2 = ohe.transform(label_2)
print(label_2)

X_train, X_test, y_train, y_test = train_test_split(train_data.iloc[:, :768], label_2, test_size=0.2, stratify=label_2, random_state=2023)

X_train_tensors = torch.tensor(X_train.iloc[:, :].values, dtype=torch.float32)
print(X_train_tensors.shape)

X_test_tensors = torch.tensor(X_test.iloc[:, :].values, dtype=torch.float32)
print(X_test_tensors.shape)

"""## Define the Model"""

class AgeClassifier(nn.Module):
    def __init__(self, dropout_prob=0.5, weight_decay=1e-5):
        super(AgeClassifier, self).__init__()
        self.linear1 = nn.Linear(768, 512)
        self.linear2 = nn.Linear(512, 256)
        self.linear3 = nn.Linear(256, 128)
        self.linear4 = nn.Linear(128, 17)

        # Set weight_decay for regularization
        self.weight_decay = weight_decay

    def forward(self, tensors):
        output_l1 = torch.relu(self.linear1(tensors))
        output_l2 = torch.relu(self.linear2(output_l1))
        output_l3 = torch.relu(self.linear3(output_l2))
        output_l4 = self.linear4(output_l3)
        return output_l4

    def l2_regularization_loss(self):
        # Calculate L2 regularization loss for linear layers
        l2_loss = 0.0
        for param in self.parameters():
            if param.requires_grad:
                l2_loss += torch.norm(param, 2)
        return self.weight_decay * l2_loss

"""## Train the model"""

# Create an instance of the AgeClassifier model
ageClassifier = AgeClassifier()

# Define a cross-entropy loss function
criterion = nn.CrossEntropyLoss()

# Create a DataLoader for batching
batch_size = 128
dataset = TensorDataset(X_train_tensors, torch.tensor(y_train))
dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

# Define an optimizer
optimizer = torch.optim.Adam(ageClassifier.parameters(), lr=0.001)

# Define early stopping parameters
patience = 25
best_validation_accuracy = 0
no_improvement_counter = 0

# Training loop
epochs = 1000
for epoch in range(epochs):

    for inputs, targets in dataloader:
        optimizer.zero_grad()
        outputs = ageClassifier(inputs)

        ce_loss = criterion(outputs, targets)
        l2_loss = ageClassifier.l2_regularization_loss()

        total_loss = ce_loss + l2_loss

        total_loss.backward()
        optimizer.step()

    # Validation step (evaluate on validation dataset)
    with torch.no_grad():
        ageClassifier.eval()
        y_test_pred = ageClassifier(X_test_tensors)
        ce = criterion(y_test_pred, torch.tensor(y_test))
        acc = (torch.argmax(y_test_pred, 1) == torch.argmax(torch.tensor(y_test), 1)).float().mean()
        ageClassifier.train()

    print(f"Epoch {epoch} validation: Cross-entropy={float(ce)}, Accuracy={float(acc)}")

    # Check for early stopping
    if acc > best_validation_accuracy:
        best_validation_accuracy = acc
        no_improvement_counter = 0
        # Save the trained best model if needed
        torch.save(ageClassifier.state_dict(), 'ageClassifier_model.pth')
    else:
        no_improvement_counter += 1

    # If no improvement for 'patience' consecutive epochs, stop training
    if no_improvement_counter >= patience:
        print("Early stopping triggered. Training stopped.")
        break

# Create an instance of the model
ageClassifier = AgeClassifier()

# Load the saved model state dictionary
ageClassifier.load_state_dict(torch.load('/content/drive/Shareddrives/test/ML _Project/ageClassifier_model.pth'))

# Validation step (evaluate on validation dataset)
with torch.no_grad():
    ageClassifier.eval()
    y_test_pred = ageClassifier(X_test_tensors)
    ce = criterion(y_test_pred, torch.tensor(y_test))
    acc = (torch.argmax(y_test_pred, 1) == torch.argmax(torch.tensor(y_test), 1)).float().mean()

print(f"Best model validation: Cross-entropy={float(ce)}, Accuracy={float(acc)}")

"""## Evaluation of the Model"""

valid_data.dropna(subset=['label_2'], inplace=True)
print(f"valid_data dataset shape {valid_data.shape}")

label_2_eval = valid_data['label_2'].values.reshape(-1, 1)
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(label_2_eval)
print(ohe.categories_)

label_2_eval = ohe.transform(label_2_eval)
print(label_2_eval)

# Set your model to evaluation mode
ageClassifier.eval()

X_valid_tensors = torch.tensor(valid_data.iloc[:, :768].values, dtype=torch.float32)
print(X_valid_tensors.shape)

y_pred = ageClassifier(X_valid_tensors)
ce = criterion(y_pred, torch.tensor(label_2_eval))
acc = (torch.argmax(y_pred, 1) == torch.argmax(torch.tensor(label_2_eval), 1)).float().mean()
print(f"Cross-entropy={float(ce)}, Test Accuracy={float(acc)}")

y_pred_labels = torch.argmax(y_pred, axis=1).numpy()
label_2_np = torch.argmax(torch.tensor(label_2_eval), axis=1).numpy()

confusion = confusion_matrix(label_2_np, y_pred_labels)
print(classification_report(label_2_np, y_pred_labels))

accuracy_score(label_2_np, y_pred_labels)

"""## Get Test Results"""

test_data.dropna(subset=['label_2'], inplace=True)
print(f"test_data dataset shape {test_data.shape}")

label_2_t = test_data['label_2'].values.reshape(-1, 1)
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(label_2_t)
print(ohe.categories_)

label_2_t = ohe.transform(label_2_t)
print(label_2_t)

# Set your model to evaluation mode
ageClassifier.eval()

X_t_tensors = torch.tensor(test_data.iloc[:, :768].values, dtype=torch.float32)
print(X_t_tensors.shape)

y_pred_t = ageClassifier(X_t_tensors)
ce = criterion(y_pred_t, torch.tensor(label_2_t))
acc = (torch.argmax(y_pred_t, 1) == torch.argmax(torch.tensor(label_2_t), 1)).float().mean()
print(f"Cross-entropy={float(ce)}, Test Accuracy={float(acc)}")

y_pred_t_labels = torch.argmax(y_pred_t, axis=1).numpy()
label_2_np_t = torch.argmax(torch.tensor(label_2_t), axis=1).numpy()

confusion = confusion_matrix(label_2_np_t, y_pred_t_labels)
print(classification_report(label_2_np_t, y_pred_t_labels))

accuracy_score(label_2_np_t, y_pred_t_labels)

"""# Train with Feature Engineering"""

data_features = train_data.iloc[:, :768]

"""## Drop Constant Features Using Variance Threshold"""

var_thres=VarianceThreshold(threshold=0)
var_thres.fit(data_features)

constant_columns = [column for column in data_features.columns
                    if column not in data_features.columns[var_thres.get_support()]]

print(constant_columns)

"""There is no constant columns

## Drop Features Using Pearson Correlation
"""

data_features.corr()

# Using Pearson Correlation
plt.figure(figsize=(12,10))
cor = data_features.corr()
sns.heatmap(cor, annot=True, cmap=plt.cm.CMRmap_r)
plt.show()

def correlation(dataset, threshold):
    correlated_pairs = set()
    corr_matrix = dataset.corr()
    for i in range(len(corr_matrix.columns)):
        for j in range(i):
            if abs(corr_matrix.iloc[i, j]) > threshold: # we are interested in absolute coeff value
                colname = corr_matrix.columns[i]  # getting the name of column
                rowname = corr_matrix.index[j]  # getting the name of row
                correlated_pairs.add((rowname, colname))
    return correlated_pairs

def get_less_correlated_features(correlated_pairs, dataset, target_column):
    less_correlated_features = {}

    for (feature1, feature2) in correlated_pairs:
        corr1 = dataset[feature1].corr(dataset[target_column])
        corr2 = dataset[feature2].corr(dataset[target_column])

        if abs(corr1) < abs(corr2):
            correlated_pair = frozenset((feature1, feature2))  # Use a frozenset as the key
            less_correlated_features[correlated_pair] = feature1
        else:
            correlated_pair = frozenset((feature1, feature2))  # Use a frozenset as the key
            less_correlated_features[correlated_pair] = feature2

    return less_correlated_features

corr_feature_pairs = correlation(data_features, 0.9)
corr_feature_pairs

less_correlated_features = get_less_correlated_features(corr_feature_pairs, train_data, "label_2")
less_correlated_features

corr_features = set(less_correlated_features.values())
corr_features

new_features = data_features.drop(corr_features,axis=1)

print(data_features.shape)
print(new_features.shape)

"""## Train the model"""

class AgeClassifierAfter(nn.Module):
    def __init__(self, dropout_prob=0.5, weight_decay=1e-5):
        super(AgeClassifierAfter, self).__init__()
        self.linear1 = nn.Linear(767, 512)
        self.linear2 = nn.Linear(512, 256)
        self.linear3 = nn.Linear(256, 128)
        self.linear4 = nn.Linear(128, 17)

        # Set weight_decay for regularization
        self.weight_decay = weight_decay

    def forward(self, tensors):
        output_l1 = torch.relu(self.linear1(tensors))
        output_l2 = torch.relu(self.linear2(output_l1))
        output_l3 = torch.relu(self.linear3(output_l2))
        output_l4 = self.linear4(output_l3)
        return output_l4

    def l2_regularization_loss(self):
        # Calculate L2 regularization loss for linear layers
        l2_loss = 0.0
        for param in self.parameters():
            if param.requires_grad:
                l2_loss += torch.norm(param, 2)
        return self.weight_decay * l2_loss

label_2 = train_data['label_2'].values.reshape(-1, 1)
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(label_2)
print(ohe.categories_)

label_2 = ohe.transform(label_2)
print(label_2)

X_train_after, X_test_after, y_train_after, y_test_after = train_test_split(new_features, label_2, test_size=0.2, stratify=label_2, random_state=2023)

X_train_tensors_after = torch.tensor(X_train_after.values, dtype=torch.float32)
print(X_train_tensors_after.shape)


X_test_tensors_after = torch.tensor(X_test_after.values, dtype=torch.float32)
print(X_test_tensors_after.shape)

y_train_after.shape

# Create an instance of the AgeClassifierAfter model
ageClassifierAfter = AgeClassifierAfter()

# Define a cross-entropy loss function
criterion = nn.CrossEntropyLoss()

# Create a DataLoader for batching
batch_size = 128
dataset = TensorDataset(X_train_tensors_after, torch.tensor(y_train_after))
dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

# Define an optimizer
optimizer = torch.optim.Adam(ageClassifierAfter.parameters(), lr=0.001)

# Define early stopping parameters
patience = 25
best_validation_accuracy = 0
no_improvement_counter = 0

# Training loop
epochs = 1000
for epoch in range(epochs):

    for inputs, targets in dataloader:
        optimizer.zero_grad()
        outputs = ageClassifierAfter(inputs)

        ce_loss = criterion(outputs, targets)
        l2_loss = ageClassifierAfter.l2_regularization_loss()

        total_loss = ce_loss + l2_loss

        total_loss.backward()
        optimizer.step()

    # Validation step (evaluate on validation dataset)
    with torch.no_grad():
        ageClassifierAfter.eval()
        y_test_pred_after = ageClassifierAfter(X_test_tensors_after)
        ce = criterion(y_test_pred_after, torch.tensor(y_test_after))
        acc = (torch.argmax(y_test_pred_after, 1) == torch.argmax(torch.tensor(y_test_after), 1)).float().mean()
        ageClassifierAfter.train()

    print(f"Epoch {epoch} validation: Cross-entropy={float(ce)}, Accuracy={float(acc)}")

    # Check for early stopping
    if acc > best_validation_accuracy:
        best_validation_accuracy = acc
        no_improvement_counter = 0
        # Save the trained best model if needed
        torch.save(ageClassifierAfter.state_dict(), 'ageClassifierAfter_model.pth')
    else:
        no_improvement_counter += 1

    # If no improvement for 'patience' consecutive epochs, stop training
    if no_improvement_counter >= patience:
        print("Early stopping triggered. Training stopped.")
        break

# Create an instance of the model
ageClassifierAfter = AgeClassifierAfter()

# Define a cross-entropy loss function
criterion = nn.CrossEntropyLoss()

# Load the saved model state dictionary
ageClassifierAfter.load_state_dict(torch.load('/content/drive/Shareddrives/test/ML _Project/ageClassifierAfter_model.pth'))

# Validation step (evaluate on validation dataset)
with torch.no_grad():
    ageClassifierAfter.eval()
    y_test_pred_after = ageClassifierAfter(X_test_tensors_after)
    ce = criterion(y_test_pred_after, torch.tensor(y_test_after))
    acc = (torch.argmax(y_test_pred_after, 1) == torch.argmax(torch.tensor(y_test_after), 1)).float().mean()

print(f"Best model validation: Cross-entropy={float(ce)}, Accuracy={float(acc)}")

"""## Evaluation of the Model"""

# Set your model to evaluation mode
ageClassifierAfter.eval()

new_features_valid = valid_data.iloc[:, :768].drop(corr_features,axis=1)
X_valid_tensors_after = torch.tensor(new_features_valid.values, dtype=torch.float32)
print(X_valid_tensors_after.shape)

y_pred_valid_after = ageClassifierAfter(X_valid_tensors_after)
ce = criterion(y_pred_valid_after, torch.tensor(label_2_eval))
acc = (torch.argmax(y_pred_valid_after, 1) == torch.argmax(torch.tensor(label_2_eval), 1)).float().mean()
print(f"Cross-entropy={float(ce)}, Test Accuracy={float(acc)}")

y_pred_valid_after_labels = torch.argmax(y_pred_valid_after, axis=1).numpy()
label_2_np_valid_after = torch.argmax(torch.tensor(label_2_eval), axis=1).numpy()

confusion = confusion_matrix(label_2_np_valid_after, y_pred_valid_after_labels)
print(classification_report(label_2_np_valid_after, y_pred_valid_after_labels))

accuracy_score(label_2_np_valid_after, y_pred_valid_after_labels)

"""## Get Test Results"""

# Set your model to evaluation mode
ageClassifierAfter.eval()

new_features_test = test_data.iloc[:, :768].drop(corr_features,axis=1)
X_t_tensors_after = torch.tensor(new_features_test.values, dtype=torch.float32)
print(X_t_tensors_after.shape)

y_pred_t_after = ageClassifierAfter(X_t_tensors_after)
print(y_pred_t_after.shape)

y_pred_one_hot = ohe.inverse_transform(y_pred_t_after.detach().numpy())
test_data["label_2"] = pd.DataFrame(y_pred_one_hot, columns=["label_2"])

test_data.head()

file_path = "/content/drive/MyDrive/#Semester07/CS4622/ML Project/speech-based-classification-layer-9/label_2.csv"

# Save the DataFrame to a CSV file
test_data.to_csv(file_path, index=False)